{"id":"recaf-mcp-00t","title":"Implement remaining stubs in partial providers (10 tools)","description":"Implement individual stubbed tools in providers that are partially implemented:\n\n**MappingToolProvider (4 stubs):**\n- rename-variable: Rename a local variable\n- mapping-apply: Apply a mapping file (e.g. ProGuard, SRG)\n- mapping-export: Export current mappings to a file format\n- mapping-list-formats: List supported mapping formats\n\n**WorkspaceToolProvider (2 stubs):**\n- workspace-export: Export workspace to a JAR/file\n- workspace-get-history: Get workspace modification history\n\n**SearchToolProvider (1 stub):**\n- search-instructions: Search for specific bytecode instructions\n\n**CallGraphToolProvider (1 stub):**\n- callgraph-path: Find call path between two methods\n\n**XRefToolProvider (1 stub):**\n- xrefs-from: Get outgoing cross-references from a class/method","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:04.317636105-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:18:31.219924111-05:00","closed_at":"2026-02-13T17:18:31.219924111-05:00","close_reason":"Implemented 10 tools across 5 providers: rename-variable, mapping-apply, mapping-export, mapping-list-formats, workspace-export, workspace-get-history, search-instructions, callgraph-path, xrefs-from"}
{"id":"recaf-mcp-01o","title":"Stack trace simulation via static call graph analysis","description":"Tool to predict possible stack traces without execution. simulate-stack-trace(rootClass, rootMethod, targetClass, targetMethod, maxDepth) performs BFS over Recaf's existing CallGraphService to reconstruct all possible call paths. Annotates paths as 'definite' vs 'conditional'. Includes static initializer (clinit) chain tracking. ~80-120 LOC extending CallGraphToolProvider. No new dependencies - leverages existing call graph infrastructure.","notes":"Feasibility: Easy (for static approach). Scope: Small (1-2 days). User wanted to reason about stack-trace-based XOR key derivation without running code. Simple BFS approach covers 80% of use case. Full symbolic execution (SSVM, JBSE) NOT recommended - SSVM is stalled (last release 2022), JBSE/SPF too heavy. Could revisit symbolic execution as separate P3 feature if users need actual value reconstruction.","status":"open","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:27:02.257195367-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:27:02.257195367-05:00"}
{"id":"recaf-mcp-02j","title":"Test: Navigation tools (class-list, class-get-info, package-list)","description":"With a workspace open, test class-list with pagination, class-count, class-get-info on a known class, package-list, method-list, field-list.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:11.442310583-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:05:58.770074737-05:00","closed_at":"2026-02-13T15:05:58.770074737-05:00","close_reason":"All 6 navigation tools pass: class-list, class-count, class-get-info, class-get-hierarchy, method-list, field-list","dependencies":[{"issue_id":"recaf-mcp-02j","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:28.287728041-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-07c","title":"Research: bytecode pattern search via MCP","description":"## Context\nDuring RLPL sideload analysis, we repeatedly needed to find specific bytecode patterns across obfuscated classes:\n- All `invokedynamic` call sites in a class (to extract encrypted bootstrap args)\n- All calls to `a(II)String` (to extract XOR string decrypt arguments)\n- Time-bomb patterns: `System.currentTimeMillis()` followed by `lcmp` + `ifle`/`ifgt`\n- All references to `bigdick55_10.2(String)` (to find which classes use the shared string decryptor)\n- All `monitorexit` on null (exception-flow control pattern)\n\nWe had to disassemble entire methods (some 4000+ lines of JASM) and grep through them externally. The existing `search-instructions` tool searches by opcode name but may not support the rich pattern matching needed.\n\n## Desired Capability\nA `search-bytecode-pattern` or enhanced `search-instructions` tool that can find:\n1. Specific opcode + operand combinations (e.g. `invokedynamic` with specific bootstrap method)\n2. Opcode sequences (e.g. `ldc \u003clong\u003e; lcmp; ifle` = time-bomb pattern)\n3. Method call targets (e.g. \"all calls to bigdick55_10.2\")\n4. Return context: which class/method/offset contains the match\n\n## Research Questions\n1. What does Recaf's existing `search-instructions` API support? Check `InstructionSearch` or similar in the Recaf codebase.\n2. Does Recaf have an ASM visitor or bytecode query API that could support pattern matching?\n3. Could we leverage Recaf's `SearchService` with custom `Query` implementations?\n4. Is there a way to search across the JASM disassembly output (text-based search on disassembled bytecode)?\n5. What about the existing `xrefs-to` / `xrefs-from` tools - do they cover method call targets already? (They might solve case 3 above.)\n6. Check if `search-references` already handles some of these cases - it searches for references to classes/methods/fields.\n\n## Concrete Examples\n```\n// Find all invokedynamic sites in HTTP client class:\ntools/call search-bytecode-pattern {\n  \"className\": \"com.*implements.*if.*boolean.IiIIiiIiii\",\n  \"opcode\": \"invokedynamic\"\n}\n// Returns: [{method:\"$catch$class\", offset:42, name:\"ie\", desc:\"...\"}, ...]\n\n// Find time-bomb pattern across all classes:\ntools/call search-bytecode-pattern {\n  \"pattern\": \"invokestatic System.currentTimeMillis; ldc *; lcmp\",\n  \"scope\": \"all\"\n}\n\n// Find all callers of bigdick55_10.2:\n// (This might already work with xrefs-to?)\ntools/call xrefs-to {\n  \"className\": \"bigdick55_10\",\n  \"memberName\": \"2\",\n  \"memberDescriptor\": \"(Ljava/lang/String;)Ljava/lang/String;\"\n}\n```\n\n## Overlap with Existing Tools\n- `search-instructions` - check what it currently supports\n- `search-references` - may cover method reference search\n- `xrefs-to` / `xrefs-from` - may cover call target search\n- `search-declarations` - searches for declared members, not call sites\n\n## Files for Reference\n- `/tmp/httpclient_bootstraps.txt` - manually extracted invokedynamic entries (162 lines)\n- `/tmp/httpclient_a_II.jasm` - 4417-line JASM we had to grep through manually","notes":"Research complete - findings in research-07c-bytecode-search.md","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:12:40.373621555-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:37:39.37204611-05:00","closed_at":"2026-02-14T07:37:39.37204611-05:00","close_reason":"Research complete - findings in research-07c-bytecode-search.md. Key discovery: Recaf has native InstructionQuery we're not using. Identified 5 actionable improvements."}
{"id":"recaf-mcp-07z","title":"Add field-get-all-constants tool for batch constant extraction","description":"New tool in NavigationToolProvider that extracts all fields with compile-time constant values from a class. Params: className (required), includeNonStatic (optional, default false). Filters classInfo.getFields() for non-null getDefaultValue(), returns list with name/descriptor/access/value/valueType per field, plus className/constantCount/totalFieldCount summary. Useful for dumping config classes, key tables, obfuscation lookup tables. ~30 lines. See research-aev-static-field-values.md Section 3.3.","status":"closed","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T09:29:09.955007713-05:00","created_by":"tha23rd","updated_at":"2026-02-14T09:36:14.782295623-05:00","closed_at":"2026-02-14T09:36:14.782295623-05:00","close_reason":"Implemented field-get-all-constants tool with 7 unit tests - batch extraction with includeNonStatic filter","dependencies":[{"issue_id":"recaf-mcp-07z","depends_on_id":"recaf-mcp-3rw","type":"blocks","created_at":"2026-02-14T09:29:15.822250448-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-0g7","title":"Implement CommentToolProvider (4 tools)","description":"Implement the 4 stubbed comment tools:\n- comment-set: Set a comment on a class/method/field\n- comment-get: Get comments for a class/method/field\n- comment-search: Search comments by text\n- comment-delete: Delete a comment\n\nNeeds Recaf API research: look for comment/annotation services in the Recaf workspace API. Comments may be stored as workspace metadata or annotations on ClassInfo/MethodInfo objects.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:52:52.89303369-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:18:29.356111189-05:00","closed_at":"2026-02-13T17:18:29.356111189-05:00","close_reason":"Implemented 4 comment tools using Recaf CommentManager: comment-set, comment-get, comment-search, comment-delete"}
{"id":"recaf-mcp-0ta","title":"Research: batch/bulk disassembly via MCP","description":"## Context\nDuring RLPL sideload analysis, we needed to disassemble all 20 methods of the HTTP client class and all 8 methods of bigdick55_10. Each required a separate `disassemble-method` MCP call with exact className/methodName/methodDescriptor. This was tedious and slow (20+ sequential HTTP calls).\n\nWe ended up using a subagent that called `disassemble-method` in a loop, writing each to a separate file. The total output was ~500KB of JASM across 22 files.\n\n## Desired Capability\nOptions to explore:\n\n### Option A: Batch disassemble endpoint\nA `disassemble-methods` (plural) tool that accepts a class name and returns all methods' JASM in one call.\n```\ntools/call disassemble-methods {\"className\": \"bigdick55_10\"}\n// Returns: [{methodName:\"\u003cclinit\u003e\", descriptor:\"()V\", assembly:\"...\"}, ...]\n```\n\n### Option B: Enhance existing disassemble-class\nThe existing `disassemble-class` tool returns full-class JASM. Check if this already provides what we need - it may already contain all methods. If so, the issue is just documentation/awareness.\n\n### Option C: Wildcard/filter support\n```\ntools/call disassemble-method {\n  \"className\": \"com.*implements.*if.*boolean.IiIIiiIiii\",\n  \"methodName\": \"*\",  // all methods\n  \"outputFormat\": \"per-method\"  // or \"single-file\"\n}\n```\n\n## Research Questions\n1. Does `disassemble-class` already return complete JASM for all methods? If so, is it usable for large classes (the HTTP client has methods up to 180KB of JASM each)?\n2. What are the response size limits of our MCP transport? Could a 500KB+ response cause issues?\n3. Would it be better to return a resource URI pointing to the full disassembly rather than inline content?\n4. Check if Recaf's `AssemblerPipelineManager` has a \"disassemble entire class\" API vs per-method.\n5. Is there value in a \"disassemble to file\" variant that writes to a workspace temp location and returns the path?\n\n## Performance Consideration\nThe HTTP client class has methods totaling ~500KB of JASM. Returning this in a single MCP response may hit transport limits. Consider pagination or streaming.\n\n## Files for Reference\n- 22 individual JASM files in /tmp/ (httpclient_*.jasm, bd10_*.jasm)\n- `/tmp/httpclient_methods.txt` - 470KB combined disassembly (14504 lines)","status":"open","priority":3,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:12:57.474711943-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:12:57.474711943-05:00"}
{"id":"recaf-mcp-11o","title":"Task 14: MappingToolProvider (7 tools)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:18.14861335-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.97231597-05:00","closed_at":"2026-02-13T14:13:49.97231597-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-168","title":"Task 3: Create McpServerManager (Jetty + MCP lifecycle)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:45:32.552316372-05:00","created_by":"tha23rd","updated_at":"2026-02-13T13:55:32.778878923-05:00","closed_at":"2026-02-13T13:55:32.778878923-05:00","close_reason":"Closed"}
{"id":"recaf-mcp-1g6","title":"Clean up .gitignore for public release","description":"The .gitignore currently ignores docs/ and analysis/ which were used during development. Remove the docs/ and analysis/ entries so project docs are visible. Consider whether .beads/ should be tracked publicly.","status":"open","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:43.628485988-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:43.628485988-05:00","dependencies":[{"issue_id":"recaf-mcp-1g6","depends_on_id":"recaf-mcp-cop","type":"blocks","created_at":"2026-02-14T12:38:49.458100777-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-1py","title":"Task 18: TransformToolProvider (5 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:23.581878986-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.982852143-05:00","closed_at":"2026-02-13T14:13:49.982852143-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-1s8","title":"Task 17: AssemblerToolProvider (4 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:21.856220416-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.987506666-05:00","closed_at":"2026-02-13T14:13:49.987506666-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-1sk","title":"Task 7: WorkspaceToolProvider (7 tools)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:55:53.814465495-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.14610203-05:00","closed_at":"2026-02-13T14:09:44.14610203-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-29n","title":"Test: Decompiler tools (decompile-class, decompile-method, decompiler-list)","description":"Decompile a known class and method. Verify source output looks correct. List decompilers and switch between them.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:13.006322199-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:05:58.939598222-05:00","closed_at":"2026-02-13T15:05:58.939598222-05:00","close_reason":"All 3 decompiler tools pass: decompiler-list, decompile-method, decompile-diff","dependencies":[{"issue_id":"recaf-mcp-29n","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:28.455683834-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-2bk","title":"Test AttachToolProvider after implementation","description":"Test all 4 attach tools after implementation: attach-list-vms, attach-connect, attach-load-classes, attach-disconnect. Will need a running target JVM to test against.","status":"closed","priority":3,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:13.896711419-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:28:15.706216793-05:00","closed_at":"2026-02-13T17:28:15.706216793-05:00","close_reason":"4/4 stub tools callable and returning proper responses. AttachToolProvider remains stubbed pending AttachManager integration.","dependencies":[{"issue_id":"recaf-mcp-2bk","depends_on_id":"recaf-mcp-2ox","type":"blocks","created_at":"2026-02-13T16:53:21.275625942-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-2jb","title":"Task 16: CompilerToolProvider (3 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:20.377353355-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.992541292-05:00","closed_at":"2026-02-13T14:13:49.992541292-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-2ox","title":"Implement AttachToolProvider (4 tools)","description":"Implement the 4 stubbed attach tools:\n- attach-list-vms: List running JVMs available for attach\n- attach-connect: Attach to a running JVM\n- attach-load-classes: Load classes from an attached JVM\n- attach-disconnect: Disconnect from attached JVM\n\nNeeds Recaf API research: look for AttachManager or JVM attach API integration in Recaf. This is lower priority as it requires a running target JVM to test.","status":"open","priority":3,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:00.476881578-05:00","created_by":"tha23rd","updated_at":"2026-02-13T16:53:00.476881578-05:00"}
{"id":"recaf-mcp-3j5","title":"Task 12: CallGraphToolProvider (4 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:56:20.723200348-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.157300456-05:00","closed_at":"2026-02-13T14:09:44.157300456-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-3rw","title":"Add defaultValue to field-list and class-get-info output","description":"Add FieldMember.getDefaultValue() output to existing field-list and class-get-info tools in NavigationToolProvider. When a field has a non-null defaultValue (ConstantValue attribute), include 'defaultValue' and 'defaultValueType' in the field map. Add a helper method getValueTypeName() that maps Integer-\u003eint, Float-\u003efloat, Long-\u003elong, Double-\u003edouble, String-\u003eString. ~10 lines total across both tools. See research-aev-static-field-values.md Section 3.1.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T09:29:08.612205771-05:00","created_by":"tha23rd","updated_at":"2026-02-14T09:31:47.435905842-05:00","closed_at":"2026-02-14T09:31:47.435905842-05:00","close_reason":"Added defaultValue and defaultValueType to field-list and class-get-info output, with helper method and unit tests"}
{"id":"recaf-mcp-3sy","title":"SSVM submodule + Gradle build integration","description":"Add SSVM as git submodule pinned to known-good 2.0.0 commit. Configure Gradle composite build (includeBuild) to compile SSVM from source. Add shadow JAR relocation rules for ASM (org.objectweb.asm -\u003e dev.recafmcp.shadow.ssvm.asm) and CAFED00D. Verify: shadowJar builds successfully with SSVM classes included, no dependency conflicts with Recaf's ASM/CAFED00D copies. Validation: ./gradlew shadowJar succeeds, jar -tf shows shaded SSVM classes.","notes":"Parent: recaf-mcp-62g. Risk: JitPack broken for latest SSVM commits — must find working commit. SSVM deps: ASM 9.5, CAFED00D 1.10.2, jlinker 1.0.7, SLF4J 1.7.36. All need shading or version alignment.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:21:51.288499837-05:00","created_by":"tha23rd","updated_at":"2026-02-14T17:32:26.670250465-05:00","closed_at":"2026-02-14T17:32:26.670250465-05:00","close_reason":"SSVM submodule added, Gradle build integration working. shadowJar builds with 714 SSVM classes shaded, 0 leaks, all tests pass."}
{"id":"recaf-mcp-4gq","title":"vm-invoke-method tool implementation","description":"Implement vm-invoke-method in SsvmExecutionProvider. Parameters: className, methodName, methodDescriptor, args (JSON array), maxIterations. Argument mapping: JSON number -\u003e int/long/float/double (from descriptor), JSON string -\u003e String, JSON boolean -\u003e boolean, JSON null -\u003e null ref. Return value serialization: primitives as JSON values, Strings as JSON strings, arrays as JSON arrays (first 1000 elements, truncated flag), objects as {type, toString}. Capture stdout/stderr from SsvmManager. Return classesInitialized list. Handle VM exceptions: return error/message/vmStackTrace. Handle IterationLimitExceeded distinctly with retry guidance. Register provider in RecafMcpPlugin.onEnable(). Scope: static methods only. Validation: unit tests calling methods with various signatures and arg types, exception handling, iteration limit test.","notes":"Parent: recaf-mcp-62g. Depends on: SsvmManager task. Key SSVM APIs: InvocationUtil.create(vm), invokeInt/invokeLong/invokeReference/invokeVoid, Argument.int32/int64/reference.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:22:06.716803357-05:00","created_by":"tha23rd","updated_at":"2026-02-14T17:49:46.119338332-05:00","closed_at":"2026-02-14T17:49:46.119338332-05:00","close_reason":"vm-invoke-method implemented with full descriptor parsing, arg mapping, return value serialization, error handling. 38 new tests, all passing. Total test suite: 137 tests.","dependencies":[{"issue_id":"recaf-mcp-4gq","depends_on_id":"recaf-mcp-e7h","type":"blocks","created_at":"2026-02-14T17:22:36.837380565-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-4p4","title":"Control flow graph analysis and switch summarization","description":"Tools to extract and present structured CFG from method bytecode. analyze-method-cfg: basic block extraction with successor/predecessor edges as structured text. simplify-switch-statement: collapse tableswitch/lookupswitch cases with identical bodies into range summaries (e.g. 'cases 0-255 all compute i4=constant then jump to block_8'). ~1000 LOC across ControlFlowToolProvider, CfgAnalyzer, SwitchAnalyzer. Output as structured text (not graphical) optimized for AI agent consumption. Uses ASM tree API + BlwUtil for instruction formatting.","notes":"Feasibility: Medium. Scope: Medium (3-5 days). ASM lacks built-in CFG helpers but provides sufficient low-level APIs. Recaf has no existing CFG support. Key challenges: exception handler edges, large method performance. Text-based output more useful for AI agents than visual graphs.","status":"open","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:51.482239256-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:26:51.482239256-05:00"}
{"id":"recaf-mcp-4qe","title":"Test: MCP resources (recaf://workspace, recaf://classes, recaf://class/{name})","description":"Read all three MCP resources and verify JSON responses contain expected data.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:16.997958531-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:05:59.644920064-05:00","closed_at":"2026-02-13T15:05:59.644920064-05:00","close_reason":"MCP resources work with dot notation class names. Slash notation bug filed separately.","dependencies":[{"issue_id":"recaf-mcp-4qe","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:29.024916449-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-4u4","title":"Task 13: InheritanceToolProvider (3 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:56:26.12750706-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.151151116-05:00","closed_at":"2026-02-13T14:09:44.151151116-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-5go","title":"workspace-add-supporting returns unhelpful 'Internal error: null'","description":"When calling workspace-add-supporting with a path that is already the primary resource, the tool returns 'Error: Internal error: null' instead of a descriptive message like 'File is already loaded as the primary resource'. The tool correctly rejects the operation but the error message gives no useful information.","status":"open","priority":3,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T17:07:11.195910744-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:07:11.195910744-05:00"}
{"id":"recaf-mcp-62g","title":"Runtime execution/evaluation tool (evaluate-expression, call-method)","description":"Sandboxed runtime execution of workspace classes using SSVM (JVM-in-JVM bytecode interpreter). Three MCP tools in v1: vm-invoke-method, vm-get-field, vm-run-clinit. Key feature: stackTraceOverride parameter on all tools — intercepts Thread.getStackTrace() to return synthetic frames, enabling correct execution of stack-introspection-dependent obfuscation. vm-run-clinit supports allowTransitiveInit whitelist for controlled initialization ordering. All tools return classesInitialized tracking. SSVM as git submodule, shaded into plugin JAR. VM lazy-inits on first call, auto-resets on workspace change. ~1180 LOC, 5-7 days. Design doc: docs/plans/2026-02-14-ssvm-runtime-execution-design.md","design":"## Implementation Steps\n\n1. Add SSVM as git submodule pinned to known-good 2.0.0 commit\n2. Configure Gradle composite build + shadow JAR shading (relocate ASM, CAFED00D)\n3. Implement SsvmManager (~200 LOC): lazy VM bootstrap, workspace change listener, class loading bridge via SupplyingClassLoaderInstaller.supplyFromFunctions(), stdout/stderr capture via custom FileManager\n4. Implement StackTraceInterceptor (~80 LOC): VMInterface.setInvoker() hook on Thread.getStackTrace() returning synthetic StackTraceElement[] from user-specified frames\n5. Implement InitializationController (~100 LOC): hook SSVM class init path, whitelist-based clinit gating, track classesInitialized/classesDeferred per call\n6. Implement SsvmExecutionProvider (~350 LOC): vm-invoke-method (static methods, arg mapping from JSON-\u003eJVM types, return value serialization), vm-get-field (static fields, auto-clinit with stack trace override), vm-run-clinit (explicit init with allowTransitiveInit whitelist)\n7. Sandbox hardening: override Runtime.exec, configure FileManager, set maxIterations default 1M\n8. Unit tests (~400 LOC): method invocation, field reading, clinit execution, stack trace override verification, init whitelist behavior, workspace reset, timeout/iteration limits\n9. Integration test: compile test class with stack-trace-dependent logic, verify correct behavior with/without stackTraceOverride","notes":"User feedback: 'The single biggest gap. Game-changing.' Feasibility: Hard. Scope: Large (3-4 days). See research: isolated classloader approach recommended over subprocess or compile+execute.","status":"closed","priority":1,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:27.996932328-05:00","created_by":"tha23rd","updated_at":"2026-02-14T18:19:11.358943359-05:00","closed_at":"2026-02-14T18:19:11.358943359-05:00","close_reason":"SSVM runtime execution fully implemented: 3 tools (vm-invoke-method, vm-get-field, vm-run-clinit), StackTraceInterceptor, InitializationController, SsvmManager. All 7 subtasks done. 200 tests (199 pass + 1 disabled integration test awaiting JDK 11-22)."}
{"id":"recaf-mcp-78x","title":"Add field-get-value tool for targeted field constant lookup","description":"New tool in NavigationToolProvider that looks up a specific field and returns its compile-time constant value with rich context. Params: className (required), fieldName (required), fieldDescriptor (optional). Uses ClassResolver.resolveClass() + ClassInfo.getDeclaredField() or getFirstDeclaredFieldByName(). Returns: className, fieldName, fieldDescriptor, access, isStatic, isFinal, hasConstantValue, value, valueType. When value is null, includes helpful 'note' about why (e.g. initialized in \u003cclinit\u003e, or instance field). ~50 lines. See research-aev-static-field-values.md Section 3.2.","status":"closed","priority":1,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T09:29:09.200597539-05:00","created_by":"tha23rd","updated_at":"2026-02-14T09:36:14.479242282-05:00","closed_at":"2026-02-14T09:36:14.479242282-05:00","close_reason":"Implemented field-get-value tool with 17 unit tests - supports all 5 ConstantValue types, name+descriptor disambiguation, helpful null-value notes","dependencies":[{"issue_id":"recaf-mcp-78x","depends_on_id":"recaf-mcp-3rw","type":"blocks","created_at":"2026-02-14T09:29:15.501158305-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-8e1","title":"Test: XRef and CallGraph tools","description":"Test xrefs-to, xrefs-count, callgraph-build, callgraph-callers, callgraph-callees on known targets in the test JAR.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:20.230575167-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:05:59.4324107-05:00","closed_at":"2026-02-13T15:05:59.4324107-05:00","close_reason":"XRef and CallGraph tools pass: xrefs-to, xrefs-count, callgraph-build (async), callgraph-callers","dependencies":[{"issue_id":"recaf-mcp-8e1","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:29.229520978-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-8li","title":"Update README Releases link for actual repo","description":"README uses relative link ../../releases which works on GitHub. Verify it resolves correctly on tha23rd/recaf-mcp. Also verify all other links work.","status":"open","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:43.961989748-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:43.961989748-05:00","dependencies":[{"issue_id":"recaf-mcp-8li","depends_on_id":"recaf-mcp-cop","type":"blocks","created_at":"2026-02-14T12:38:49.850432475-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-9w1","title":"vm-run-clinit + InitializationController","description":"Implement InitializationController (~100 LOC) in recaf-mcp-plugin/src/main/java/dev/recafmcp/ssvm/. Hook SSVM class init path to check allowTransitiveInit whitelist before running clinit. Track classesInitialized and classesDeferred per call. Add vm-run-clinit tool to SsvmExecutionProvider. Parameters: className, stackTraceOverride, allowTransitiveInit (class name whitelist — if provided, only listed classes + target can init; if omitted, standard JVM behavior), maxIterations (default 10M). Returns: initialized boolean, stdout/stderr, classesInitialized list, classesDeferred list. Validation: unit test initializing class A that references B and C — with whitelist allowing only B, verify C appears in classesDeferred. Test stack trace override integration.","notes":"Parent: recaf-mcp-62g. Depends on: stack trace override task. This + stackTraceOverride is what turns 'multi-session investigation' into '5 MCP calls'.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:22:23.467498601-05:00","created_by":"tha23rd","updated_at":"2026-02-14T18:14:23.732600307-05:00","closed_at":"2026-02-14T18:14:23.732600307-05:00","close_reason":"vm-run-clinit implemented with InitializationController (JVMTIEnv-based ClassLink/MethodEnter listeners), allowTransitiveInit whitelist enforcement, classesInitialized/classesDeferred tracking. Fixed State.COMPLETE bug (SSVM uses IN_PROGRESS). 6 new tests (189 total). QC approved.","dependencies":[{"issue_id":"recaf-mcp-9w1","depends_on_id":"recaf-mcp-luf","type":"blocks","created_at":"2026-02-14T17:22:37.369563567-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-a8l","title":"Task 2: Create plugin skeleton","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:45:26.434430164-05:00","created_by":"tha23rd","updated_at":"2026-02-13T13:50:58.497292808-05:00","closed_at":"2026-02-13T13:50:58.497292808-05:00","close_reason":"Closed"}
{"id":"recaf-mcp-aev","title":"Research: static field value reading via MCP","description":"## Context\nDuring RLPL sideload analysis, we needed to inspect runtime values of static fields (e.g. `bigdick55_10.aiooi1iojionlknzjsdnfdas` int array, HTTP client's `a[]` and `b[]` String arrays, `bigdick55_10.MLF`/`MLG` int fields). We had to write external Java harnesses (DumpStrings.java) and run them with LD_PRELOAD hacks to read these values.\n\n## Desired Capability\nA `field-get-value` MCP tool that can read the value of static fields, at minimum for:\n- Primitive types (int, long, boolean, etc.)\n- String fields\n- Primitive arrays (int[], byte[], etc.)\n- String arrays\n\n## Research Questions\n1. Does Recaf's API expose static field values from loaded class info? Check `JvmClassInfo`, `ClassFileFields`, or similar APIs.\n2. For fields with compile-time constant values (ConstantValue attribute in bytecode), can we read those directly from the class file without execution?\n3. For fields populated at runtime (e.g. by `\u003cclinit\u003e`), is there any way to extract values statically? Options might include:\n   - Partial symbolic execution / constant folding of `\u003cclinit\u003e`\n   - Integration with Recaf's attach/debug capabilities\n   - Simply documenting this as out-of-scope (runtime-only)\n4. What about the `field-list` tool we already have - could it be extended to include initial values where available?\n5. Check if `JvmClassInfo.getFields()` returns `FieldMember` objects that expose `getConstantValue()` or similar.\n\n## Concrete Example\n```\n// Want to call:\ntools/call field-get-value {\"className\":\"bigdick55_10\",\"fieldName\":\"MLF\",\"fieldDescriptor\":\"I\"}\n// Expected: {\"value\": -1730063363, \"source\": \"constant_value_attribute\"}\n\n// Harder case - array populated by \u003cclinit\u003e:\ntools/call field-get-value {\"className\":\"bigdick55_10\",\"fieldName\":\"aiooi1iojionlknzjsdnfdas\",\"fieldDescriptor\":\"[I\"}\n// Might return: {\"value\": null, \"source\": \"runtime_only\", \"note\": \"Field initialized in \u003cclinit\u003e, not a compile-time constant\"}\n```\n\n## Files for Reference\n- `/tmp/DumpStrings.java` - the external harness we had to write\n- `/tmp/bd10_clinit.jasm` - the \u003cclinit\u003e that populates the array","notes":"Research complete - findings in research-aev-static-field-values.md","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:12:19.444237357-05:00","created_by":"tha23rd","updated_at":"2026-02-14T09:02:30.35549601-05:00","closed_at":"2026-02-14T09:02:30.35549601-05:00","close_reason":"Research complete - findings in research-aev-static-field-values.md. Key API: FieldMember.getDefaultValue() for ConstantValue attribute. 4 recommended changes."}
{"id":"recaf-mcp-al1","title":"Patch-and-run workflow tool","description":"Streamlined tool combining assemble-method + workspace-export + ProcessBuilder execution. patch-and-run(className, methodName, patchedJasm, mainClass, args, timeout) applies JASM patch, exports workspace to temp JAR, launches java process, captures stdout/stderr, cleans up. ~900-1200 LOC across PatchAndRunToolProvider, ProcessExecutor utility, TempFileManager. Key challenges: process lifecycle/timeout handling, temp file cleanup, output buffering (cap at 1MB), synchronous blocking of MCP server during execution.","notes":"Feasibility: Medium. Scope: Medium (13-19 hours). All building blocks exist (assemble-method, workspace-export). No new dependencies - uses Java stdlib ProcessBuilder. Consider splitting into patch-method + export-and-run as alternative.","status":"open","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:38.073786836-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:26:38.073786836-05:00"}
{"id":"recaf-mcp-b27","title":"Fix README clone URL placeholder","description":"README.md has 'git clone https://github.com/\u003cowner\u003e/recaf-mcp.git' — replace \u003cowner\u003e with tha23rd.","status":"open","priority":1,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:43.354261639-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:43.354261639-05:00","dependencies":[{"issue_id":"recaf-mcp-b27","depends_on_id":"recaf-mcp-cop","type":"blocks","created_at":"2026-02-14T12:38:49.26586022-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-b3f","title":"Task 1: Initialize Gradle project structure","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:45:20.422863611-05:00","created_by":"tha23rd","updated_at":"2026-02-13T13:50:11.329305894-05:00","closed_at":"2026-02-13T13:50:11.329305894-05:00","close_reason":"Closed"}
{"id":"recaf-mcp-bs7","title":"Audit git history for sensitive data","description":"Review git history for any accidentally committed secrets, API keys, or personal paths. The analysis/ dir was gitignored but verify nothing leaked into earlier commits.","status":"open","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:43.793862694-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:43.793862694-05:00","dependencies":[{"issue_id":"recaf-mcp-bs7","depends_on_id":"recaf-mcp-cop","type":"blocks","created_at":"2026-02-14T12:38:49.660228665-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-bx0","title":"Task 11: XRefToolProvider (3 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:56:15.304170704-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.162532326-05:00","closed_at":"2026-02-13T14:09:44.162532326-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-ckd","title":"MBA (Mixed Boolean Arithmetic) simplification tool","description":"Tool to simplify obfuscated constant expressions like (-1149518027) ^ (-1149518025) =\u003e 2. Phase 1: constant-folding bytecode evaluator that simulates JVM stack for sequences of constants + arithmetic/bitwise ops. ~150-200 LOC. Returns map of offset -\u003e simplified value. Phase 2 (optional): annotated JASM disassembly with inline simplified values. Phase 3 (optional): Z3 SMT solver for complex non-linear MBAs. No new dependencies for Phase 1 - pure ASM stack simulation.","notes":"Feasibility: Medium. Scope: Small-Medium (Phase 1: 1-2 weeks). Proven value from RLPL analysis where dozens of MBA expressions needed manual simplification. No existing Java MBA simplification library - we'd be filling a gap. References: MBA-Blast (USENIX 2021), ProMBA (CCS 2023).","status":"open","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:45.651244704-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:26:45.651244704-05:00"}
{"id":"recaf-mcp-cop","title":"Prepare repo for public release","description":"Get recaf-mcp ready to make the GitHub repo public. Includes license, .gitignore audit, sensitive data check, README polish, and any remaining rough edges.","status":"open","priority":1,"issue_type":"epic","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:07.000133809-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:07.000133809-05:00"}
{"id":"recaf-mcp-d2p","title":"Test: MCP tool listing returns all 65 tools","description":"After MCP server is running, send tools/list request and verify all 65 tools are registered with correct names and schemas.","status":"closed","priority":0,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:07.545645799-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:02:18.490876017-05:00","closed_at":"2026-02-13T15:02:18.490876017-05:00","close_reason":"tools/list returns all 65 tools via SSE","dependencies":[{"issue_id":"recaf-mcp-d2p","depends_on_id":"recaf-mcp-nd5","type":"blocks","created_at":"2026-02-13T14:22:27.869701487-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-dgj","title":"Task 10: SearchToolProvider (8 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:56:09.923738294-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.167533551-05:00","closed_at":"2026-02-13T14:09:44.167533551-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-dhc","title":"inheritance-common-parent has transient 'Failed to get current workspace graph' error","description":"The inheritance-common-parent tool returned 'Failed to get current workspace graph' on the first call with dot-notation class names, but succeeded on retry. This suggests a lazy initialization race condition in the inheritance graph retrieval path. The other inheritance tools (subtypes, supertypes) did not exhibit this issue.","status":"open","priority":3,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T17:07:16.038797503-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:07:16.038797503-05:00"}
{"id":"recaf-mcp-dt3","title":"Add LICENSE file","description":"Choose and add a license (MIT, Apache 2.0, etc.). Remove the placeholder [TODO: Add license] from README.md.","status":"open","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T12:38:42.98265461-05:00","created_by":"tha23rd","updated_at":"2026-02-14T12:38:42.98265461-05:00","dependencies":[{"issue_id":"recaf-mcp-dt3","depends_on_id":"recaf-mcp-cop","type":"blocks","created_at":"2026-02-14T12:38:49.087993555-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-dv5","title":"Make SSVM build Java 11 path configurable for CI","description":"The SSVM build task in build.gradle hardcodes JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 for building SSVM as a subprocess. This works locally but will break in GitHub Actions (different path, possibly needs setup-java). Make the path configurable via a Gradle property (e.g. -PssvmJavaHome=...) with a sensible default. Update CI workflow to set up Java 11 alongside Java 22+ and pass the path.","notes":"Created from recaf-mcp-3sy implementation. The SSVM submodule uses Gradle 7.3 which is incompatible with our Gradle 9.3.1 for includeBuild, so it's built as a subprocess with its own JDK.","status":"open","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:42:17.836633864-05:00","created_by":"tha23rd","updated_at":"2026-02-14T17:42:17.836633864-05:00"}
{"id":"recaf-mcp-e7h","title":"SsvmManager: VM lifecycle, workspace bridge, lazy init","description":"Implement SsvmManager (~200 LOC) in recaf-mcp-plugin/src/main/java/dev/recafmcp/ssvm/. Responsibilities: (1) Lazy VM bootstrap on first access (~2-10s), reuse across calls. (2) Class loading bridge via SupplyingClassLoaderInstaller.supplyFromFunctions() resolving from workspace primary + supporting resources. (3) Custom FileManager capturing stdout/stderr to ByteArrayOutputStream. (4) Workspace change listener (addWorkspaceOpenListener/CloseListener) that discards VM on workspace modification. (5) Synchronized access (one tool call at a time). (6) Sandbox: override Runtime.exec via VMInterface.setInvoker() to block, set default maxIterations to 10M. Validation: unit test that bootstraps SSVM, loads a synthetic class from mock workspace, verifies class is accessible. Test workspace reset by simulating workspace change event.","notes":"Parent: recaf-mcp-62g. Depends on: SSVM submodule task. Key SSVM APIs: VirtualMachine, SupplyingClassLoaderInstaller.supplyFromFunctions(), HostFileManager, VMInterface.setInvoker(), Interpreter.setMaxIterations().","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:21:59.293021984-05:00","created_by":"tha23rd","updated_at":"2026-02-14T17:43:06.644966208-05:00","closed_at":"2026-02-14T17:43:06.644966208-05:00","close_reason":"SsvmManager implemented (342 LOC) with 20 passing tests. Lazy bootstrap, workspace bridge, stdout capture, auto-reset on workspace change, sandbox defaults all working.","dependencies":[{"issue_id":"recaf-mcp-e7h","depends_on_id":"recaf-mcp-3sy","type":"blocks","created_at":"2026-02-14T17:22:36.638669167-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-e9s","title":"Add workspace-export MCP tool","description":"Investigate Recaf's workspace export API and implement a workspace-export MCP tool. This would allow exporting the current workspace (with any bytecode patches applied) to a JAR file. Critical for the bytecode patching workflow where you patch methods via assemble-method then need to export the modified JAR to run it externally.","status":"closed","priority":2,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T18:19:13.108976358-05:00","created_by":"tha23rd","updated_at":"2026-02-13T19:05:39.771613922-05:00","closed_at":"2026-02-13T19:05:39.771613922-05:00","close_reason":"workspace-export tool now exists in current Recaf build (confirmed working - used to export patched JARs)"}
{"id":"recaf-mcp-fxz","title":"Task 8: NavigationToolProvider (8 tools)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:55:59.133760163-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.140956823-05:00","closed_at":"2026-02-13T14:09:44.140956823-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-g01","title":"Test TransformToolProvider after implementation","description":"Test all 5 transform tools after implementation: transform-list, transform-apply, transform-apply-batch, transform-preview, transform-undo. Verify each via MCP HTTP calls.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:13.068823363-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:28:11.046954682-05:00","closed_at":"2026-02-13T17:28:11.046954682-05:00","close_reason":"6/6 tests pass: transform-list (27 transformers), transform-preview, transform-apply, transform-undo, transform-apply-batch (2 transforms), undo after batch. All working.","dependencies":[{"issue_id":"recaf-mcp-g01","depends_on_id":"recaf-mcp-ue8","type":"blocks","created_at":"2026-02-13T16:53:21.026740036-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-g3r","title":"Runtime field value reading via JDI attach","description":"Read actual field values from a running JVM via JDI (Java Debug Interface). Would enable reading fields whose values differ at runtime vs compile-time (e.g. arrays initialized in clinit). Approach: JDI VirtualMachine.attach(pid) + ReferenceType.getValue(Field). DECISION: This is generic JVM debugging tooling that doesn't require Recaf's workspace. Better implemented as a separate standalone JDI tool/MCP server. An agent can orchestrate Recaf + JDI tool together.","notes":"User feedback: 'would have short-circuited days of wrong-random-array debugging.' Feasibility: Medium. WON'T DO in this repo - belongs as separate tool. Core JDI capability is independent of Recaf workspace.","status":"closed","priority":4,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:32.209676604-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:27:07.937065901-05:00","closed_at":"2026-02-14T16:27:07.937065901-05:00","close_reason":"Won't implement in this repo. JDI attach/field reading is generic JVM tooling independent of Recaf's workspace. Better as a separate standalone JDI tool or MCP server. An agent can orchestrate Recaf + JDI tool together."}
{"id":"recaf-mcp-ga4","title":"Test remaining partial stubs after implementation","description":"Test the 10 tools from partial providers after implementation: rename-variable, mapping-apply, mapping-export, mapping-list-formats, workspace-export, workspace-get-history, search-instructions, callgraph-path, xrefs-from.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:14.946982935-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:28:11.214899941-05:00","closed_at":"2026-02-13T17:28:11.214899941-05:00","close_reason":"10/10 tests pass: mapping-list-formats (7 formats), mapping-apply (Proguard), mapping-export, rename-variable (valid error - no debug info), workspace-export (22MB JAR), workspace-get-history, search-instructions, callgraph-path (2-hop path found), xrefs-from (5 method refs).","dependencies":[{"issue_id":"recaf-mcp-ga4","depends_on_id":"recaf-mcp-00t","type":"blocks","created_at":"2026-02-13T16:53:21.439047831-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-his","title":"Fix xrefs-from to handle InvokeDynamicInsnNode","description":"XRefToolProvider.xrefs-from silently skips InvokeDynamicInsnNode instructions - the switch at line ~161-183 only handles MethodInsnNode, FieldInsnNode, TypeInsnNode. Add a case for InvokeDynamicInsnNode that includes bootstrapOwner/Name/Desc, callName/Desc, type=invokedynamic, and bsmArgs. ~15 lines. See research-07c-bytecode-search.md Recommendation 4.","status":"closed","priority":2,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:40:28.176970934-05:00","created_by":"tha23rd","updated_at":"2026-02-14T08:59:17.202924746-05:00","closed_at":"2026-02-14T08:59:17.202924746-05:00","close_reason":"Add InvokeDynamicInsnNode case to xrefs-from switch statement, extracting bootstrap method owner/name/descriptor, call name/descriptor, and bootstrap args"}
{"id":"recaf-mcp-hko","title":"Test CommentToolProvider after implementation","description":"Test all 4 comment tools after implementation: comment-set, comment-get, comment-search, comment-delete. Verify each via MCP HTTP calls with valid arguments.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:10.094340396-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:28:10.712976578-05:00","closed_at":"2026-02-13T17:28:10.712976578-05:00","close_reason":"7/7 tests pass: comment-set (class+method), comment-get (class+method), comment-search, comment-delete, verify deletion. Full CRUD lifecycle works.","dependencies":[{"issue_id":"recaf-mcp-hko","depends_on_id":"recaf-mcp-0g7","type":"blocks","created_at":"2026-02-13T16:53:20.655942868-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-iek","title":"Test: Search tools (search-strings, search-references, search-declarations)","description":"Search for known strings, references, and declarations in the test JAR. Verify results are accurate and pagination works.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:14.382417446-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:05:59.163106821-05:00","closed_at":"2026-02-13T15:05:59.163106821-05:00","close_reason":"All 5 search tools pass: search-strings, search-strings-count, search-references, search-declarations, search-files","dependencies":[{"issue_id":"recaf-mcp-iek","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:28.634980081-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-jck","title":"Task 15: CommentToolProvider (4 tools)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:19.317357345-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.966942512-05:00","closed_at":"2026-02-13T14:13:49.966942512-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-kh9","title":"Static vs runtime class state diff","description":"Compare workspace class (as loaded from JAR) vs class in a running JVM to detect runtime bytecode modifications. DECISION: The core capability (extracting bytecode from running JVM via JDI/Instrumentation API) is generic JVM tooling that doesn't require Recaf. Better implemented as part of a separate JDI tool/MCP server. The comparison workflow can be orchestrated by an agent using Recaf's static analysis + separate JDI tool.","notes":"User feedback: 'would have immediately flagged the runtime modifications.' Feasibility: Hard (Medium for metadata-only). WON'T DO in this repo - depends on JVM attach infrastructure that belongs in a separate tool. Related to runtime field reading (same JDI dependency).","status":"closed","priority":4,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T16:26:55.94289458-05:00","created_by":"tha23rd","updated_at":"2026-02-14T16:27:08.164378938-05:00","closed_at":"2026-02-14T16:27:08.164378938-05:00","close_reason":"Won't implement in this repo. Runtime bytecode extraction via JDI/Instrumentation is generic JVM tooling. Same reasoning as runtime field reading - belongs in a separate JDI tool. Comparison can be agent-orchestrated."}
{"id":"recaf-mcp-kmm","title":"Implement AssemblerToolProvider (4 tools)","description":"Implement the 4 stubbed assembler tools:\n- disassemble-method: Get JASM/Bytecode assembly for a method\n- assemble-method: Assemble JASM/Bytecode back into a method\n- disassemble-class: Get full class assembly\n- assemble-class: Assemble full class from JASM\n\nNeeds Recaf API research: look for JvmAssembler / Assembler services. Recaf supports JASM format for bytecode assembly/disassembly.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:52:56.911305873-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:18:29.827965411-05:00","closed_at":"2026-02-13T17:18:29.827965411-05:00","close_reason":"Implemented 4 assembler tools using Recaf JASM AssemblerPipelineManager: disassemble-method, assemble-method, disassemble-class, assemble-class"}
{"id":"recaf-mcp-kqz","title":"Test: Python bridge end-to-end","description":"Start Recaf, then run the Python bridge. Verify it connects and can proxy tool calls from stdio to HTTP.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:18.638378333-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:39:09.026268125-05:00","closed_at":"2026-02-13T15:39:09.026268125-05:00","close_reason":"All 6 bridge e2e tests pass: init, tools/list (65 tools), call class-list, call decompile-class, resources/list (2 resources), read recaf://workspace. Fixed bridge URL from /mcp/message to /mcp.","dependencies":[{"issue_id":"recaf-mcp-kqz","depends_on_id":"recaf-mcp-nd5","type":"blocks","created_at":"2026-02-13T14:22:29.474142497-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-l9g","title":"Research: decompiler fallback/JASM hybrid view for obfuscated code","description":"## Context\nDuring RLPL sideload analysis, the Java decompiler was essentially useless for heavily obfuscated methods. The obfuscation uses:\n- Exception-based control flow (monitorexit on null → IMSE/NPE as goto)\n- 256-entry tableswitches with opaque predicates\n- Anti-tamper invokedynamic traps (while()V, fuck()B)\n- Opaque arithmetic (XOR disguised as (a|b)\u0026~(a\u0026b), (a|b)-(a\u0026b), etc.)\n\nThe decompiler either produced garbage Java or failed entirely. We relied exclusively on JASM disassembly, but raw JASM is very verbose (4000+ lines for a single method).\n\n## Desired Capability\nExplore whether Recaf or our plugin can provide a more useful view for obfuscated code:\n\n### Option A: Annotated JASM\nEnhance disassembly output with automatic annotations:\n- Resolve invokedynamic targets inline (show what the bootstrap resolves to)\n- Simplify opaque predicates (recognize XOR patterns and show simplified form)\n- Mark exception-flow control (identify \"exception as goto\" patterns)\n- Fold constant expressions (e.g. `ldc 1903826347L; l2i; ldc 1903826347; ... isub` → `0`)\n\n### Option B: Decompiler hints/fallback\nWhen the decompiler fails on a method, provide a structured summary:\n- Method signature and parameter types\n- Called methods (callees) with resolved names\n- String constants referenced\n- Control flow graph summary (basic blocks + edges)\n- Exception handler table in readable form\n\n### Option C: Partial decompilation\nDecompile the parts that CAN be decompiled and show JASM for the rest.\n\n## Research Questions\n1. Does Recaf support multiple decompiler backends? Check if any handle obfuscated code better.\n   - We have `decompiler-list` and `decompiler-set` tools\n   - Test: CFR, Procyon, FernFlower, Vineflower on the obfuscated methods\n2. Does Recaf have a control flow graph API? Could we expose a `get-control-flow-graph` tool?\n3. Can Recaf's ASM integration provide a simplified/annotated instruction view?\n4. Is there a way to get a \"method summary\" (callees, string refs, field accesses) without full decompilation?\n   - This might overlap with `callgraph-callees` (already implemented)\n5. Could we add opaque predicate simplification as a transform? Recaf has `transform-*` tools.\n6. Check if any Recaf transforms already handle deobfuscation (e.g. constant folding, dead code removal).\n\n## Concrete Example - What We Wanted vs What We Got\n\n### What decompiler produced (useless):\n```java\n// Decompiler failed or produced:\npublic static String a(int var0, int var1) {\n    // ... hundreds of lines of meaningless variable shuffling ...\n}\n```\n\n### What would have been useful:\n```\nMethod: a(II)Ljava/lang/String;\n  Computes: array_index = opaque_xor(arg0, arg1)  // i2 = f(i0,i1)\n  Loads: this.a[array_index] (String)\n  Checks cache: this.b[array_index]\n  XOR decrypt: first_char → 256-way tableswitch → xor_key\n  Returns: decrypted string\n  \n  Callees: String.toCharArray, String.\u003cinit\u003e([C)\n  Time-bomb: Instant.now() comparison at offset 0x1A3\n  Anti-tamper: invokedynamic while()V at offset 0x00\n```\n\n## Files for Reference\n- `/tmp/httpclient_a_II.jasm` - 4417 lines of JASM that encodes a relatively simple XOR decryptor\n- `/tmp/bd10_method0.jasm` - 16-state exception-flow state machine","status":"open","priority":3,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:13:56.058677459-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:13:56.058677459-05:00"}
{"id":"recaf-mcp-luf","title":"Stack trace override (StackTraceInterceptor)","description":"Implement StackTraceInterceptor (~80 LOC) in recaf-mcp-plugin/src/main/java/dev/recafmcp/ssvm/. Uses VMInterface.setInvoker() to intercept Thread.getStackTrace() and return synthetic StackTraceElement[] from user-specified frames. Add stackTraceOverride parameter to vm-invoke-method and vm-get-field. Parameter format: JSON array of {className, methodName, fileName?, lineNumber?}. IMPORTANT: frame indexing matters — obfuscators read specific indices (e.g. getStackTrace()[3]). Override array must be positioned correctly. Validation: unit test with a method that reads getStackTrace()[N] and returns the class name — verify it returns the overridden value. Test without override to confirm default SSVM behavior.","notes":"Parent: recaf-mcp-62g. Depends on: vm-get-field task (needs both tools to wire into). This is the key differentiator — solves stack-introspection-dependent key derivation that was the actual blocker in RLPL analysis.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:22:17.484215062-05:00","created_by":"tha23rd","updated_at":"2026-02-14T18:04:18.743972168-05:00","closed_at":"2026-02-14T18:04:18.743972168-05:00","close_reason":"StackTraceInterceptor implemented: VMInterface.setInvoker() intercepts Thread.getStackTrace(), builds synthetic StackTraceElement[] from user frames. stackTraceOverride param added to both vm-invoke-method and vm-get-field. Install/uninstall in try/finally. 10 new tests (183 total). QC approved.","dependencies":[{"issue_id":"recaf-mcp-luf","depends_on_id":"recaf-mcp-txp","type":"blocks","created_at":"2026-02-14T17:22:37.191467477-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-m21","title":"Replace formatInstruction() with BlwUtil.toString() in search-instructions","description":"Quick fix: replace the custom formatInstruction() method in SearchToolProvider with Recaf's BlwUtil.toString(). This immediately fixes missing InvokeDynamicInsnNode, JumpInsnNode, IincInsnNode, and switch instruction formatting. Output shifts to JASM syntax which matches disassemble-method output. ~5 min effort. See research-07c-bytecode-search.md Recommendation 2.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:40:22.911781272-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:49:30.711592617-05:00","closed_at":"2026-02-14T07:49:30.711592617-05:00","close_reason":"Replaced formatInstruction() with BlwUtil.toString() - 22 unit tests passing, build green"}
{"id":"recaf-mcp-m7j","title":"Add search-invokedynamic specialized tool","description":"Purpose-built tool for finding and inspecting invokedynamic call sites across the workspace. Parameters: bootstrapOwner, bootstrapName, callName, classFilter (all optional regex). Returns rich structured data per match: className, methodName, methodDescriptor, instructionIndex, bootstrapMethod details, callSite details, bootstrapArgs list. Could be a convenience wrapper around search-instruction-sequence or a custom ASM visitor. ~100-150 lines. See research-07c-bytecode-search.md Recommendation 5.","status":"open","priority":3,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:40:30.226564277-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:40:30.226564277-05:00"}
{"id":"recaf-mcp-m87","title":"Test untested implemented tools: Inheritance, Workspace, misc","description":"Test all implemented tools that haven't been individually verified yet:\n\n**InheritanceToolProvider (3 tools - all untested):**\n- inheritance-subtypes\n- inheritance-supertypes  \n- inheritance-common-parent\n\n**WorkspaceToolProvider (untested implemented tools):**\n- workspace-open\n- workspace-close\n- workspace-list-resources\n- workspace-add-supporting\n\n**Misc untested tools in partially-implemented providers:**\n- decompiler-set (DecompilerToolProvider)\n- search-numbers (SearchToolProvider)\n- search-text-in-decompilation (SearchToolProvider)\n- callgraph-callees (CallGraphToolProvider)\n- phantom-generate (CompilerToolProvider)\n\nEach tool should be called via MCP HTTP with valid arguments and verified to return meaningful results.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:52:46.46749372-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:03:09.260673138-05:00","closed_at":"2026-02-13T17:03:09.260673138-05:00","close_reason":"All 12 implemented-but-untested tools verified: inheritance (3/3), workspace (4/4), decompiler-set, search-numbers, search-text-in-decompilation, callgraph-callees, phantom-generate. Minor issues noted: classFilter may not work in search-text-in-decompilation, workspace-add-supporting has unhelpful null error message."}
{"id":"recaf-mcp-ms1","title":"SSVM integration test: stack-dependent obfuscation scenario","description":"End-to-end integration test simulating the RLPL sideload workflow. Create synthetic test classes using ASM ClassWriter: (1) DecryptionEngine with clinit that initializes a random array + decrypt method that uses Thread.getStackTrace()[3] for XOR key derivation. (2) TargetClass with clinit that calls DecryptionEngine.decrypt() to populate static String fields. (3) CacheClass with static ConcurrentHashMap. Test workflow: Step 1: vm-run-clinit on DecryptionEngine. Step 2: vm-get-field to read runtime random array. Step 3: vm-run-clinit on TargetClass with stackTraceOverride positioning TargetClass.clinit at frame index 3, allowTransitiveInit=[DecryptionEngine, CacheClass]. Step 4: vm-get-field to read decrypted strings. Step 5: vm-invoke-method calling decrypt directly with stackTraceOverride. Verify all return correct values. Verify classesInitialized/classesDeferred tracking. Verify without stackTraceOverride produces wrong values.","notes":"Parent: recaf-mcp-62g. Depends on: vm-run-clinit task. This test validates the entire design against the real-world scenario that motivated the feature.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:22:31.12673006-05:00","created_by":"tha23rd","updated_at":"2026-02-14T18:19:04.983839945-05:00","closed_at":"2026-02-14T18:19:04.983839945-05:00","close_reason":"Integration test created: SsvmIntegrationTest (disabled, needs JDK 11-22) with realistic obfuscation scenario using ASM-generated classes, stack trace override, allowTransitiveInit. Plus InitializationControllerTest (9 tests) and extended VmRunClinit tests. 200 total tests (199 pass + 1 disabled). QC approved.","dependencies":[{"issue_id":"recaf-mcp-ms1","depends_on_id":"recaf-mcp-9w1","type":"blocks","created_at":"2026-02-14T17:22:37.551874397-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-nap","title":"Research: low-level bytecode patching via MCP","description":"## Context\nDuring RLPL sideload analysis, we needed to make surgical bytecode patches:\n1. Replace time-bomb conditional jumps with `nop` (6 locations across 3 classes)\n2. Insert `System.out.println` calls to trace decryption (2 locations in bigdick55_10)\n3. Replace `System.exit(0)` calls with `nop`\n\nOur workflow was cumbersome:\n1. `workspace-export` the entire JAR\n2. Use external tools to identify patch offsets\n3. Manually edit bytecode or use the `assemble-method` tool\n4. Re-import the patched JAR\n\nFor simple patches like \"replace instruction X at offset Y with nop\", this is overkill.\n\n## Desired Capability\nExplore what level of bytecode patching Recaf can support via MCP:\n\n### Option A: Instruction-level patch tool\n```\ntools/call patch-instruction {\n  \"className\": \"bigdick55_10\",\n  \"methodName\": \"\u003cclinit\u003e\",\n  \"methodDescriptor\": \"()V\",\n  \"offset\": 42,           // bytecode offset\n  \"replacement\": \"nop\"    // or \"return\", \"iconst_0\", etc.\n}\n```\n\n### Option B: Pattern-based patch\n```\ntools/call patch-pattern {\n  \"className\": \"bigdick55_10\",\n  \"methodName\": \"\u003cclinit\u003e\",\n  \"pattern\": \"invokestatic System.exit\",\n  \"replacement\": \"pop; nop\"  // pop the arg, nop the call\n}\n```\n\n### Option C: Enhanced assemble-method workflow\nThe existing `assemble-method` already allows replacing an entire method's bytecode via JASM. The question is whether this is sufficient or if finer-grained patching adds real value.\n\n## Research Questions\n1. Does Recaf have an API for modifying individual instructions without rewriting the entire method?\n   - Check `ClassWriter`, `MethodWriter`, or ASM's `MethodVisitor` integration\n2. Can Recaf's `assemble-method` tool handle partial method replacement (e.g. replace one instruction)?\n3. Does Recaf expose bytecode offsets in its API, or only label-based addressing (as in JASM)?\n4. What about Recaf's `transform-apply` tool - could custom transforms handle these patch cases?\n   - We have `transform-list`, `transform-apply`, `transform-apply-batch` already\n   - Check if any built-in transforms do instruction replacement\n5. Is there a risk of invalidating stack maps or other verification metadata with raw patches?\n   - Recaf may handle stack map recomputation automatically\n6. Would a \"patch and verify\" workflow be better (apply patch, then run verifier)?\n\n## Real-World Patch Examples from RLPL Analysis\n```\n// Time-bomb: replace \"ifle B\" with \"goto B\" (always skip exit)\n// In JASM: change \"ldc 1768500606166L; lcmp; ifle B\" to \"pop2; goto B\"\n\n// System.exit removal: replace \"invokestatic System.exit(I)V\" with \"pop; nop\"\n\n// Debug injection: before \"areturn\", insert \"dup; invokevirtual println\"\n// This is HARD to do without full method rewrite\n```\n\n## Existing Tools That May Cover This\n- `assemble-method` - full method replacement via JASM (already works, used successfully)\n- `assemble-class` - full class replacement\n- `transform-apply` - built-in transformations\n- The question is whether these are sufficient or if lower-level patching adds real value\n\n## Files for Reference\n- `/tmp/rlpl-patched2.jar` - JAR with our manual patches applied\n- `/tmp/bd10_clinit.jasm` - example of a method we needed to patch (massive, only needed 2 instruction changes)","status":"open","priority":3,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:13:20.567469899-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:13:20.567469899-05:00"}
{"id":"recaf-mcp-nd5","title":"Test: Recaf plugin loads and MCP server starts","description":"Run ./gradlew runRecaf and verify: plugin loads, MCP server starts on port 8085, log line appears. Then curl the /mcp/message endpoint with an initialize request.","status":"closed","priority":0,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:05.652521479-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:02:18.288918975-05:00","closed_at":"2026-02-13T15:02:18.288918975-05:00","close_reason":"MCP server starts successfully, all 65 tools registered"}
{"id":"recaf-mcp-oht","title":"Add search-instruction-sequence tool using Recaf InstructionQuery","description":"Expose Recaf's native InstructionQuery through a new search-instruction-sequence MCP tool. Takes an array of regex patterns (one per consecutive instruction), each matched against BlwUtil.toString() JASM-formatted text. Uses SearchService.search() for parallelized whole-workspace search. Returns InstructionPathNode results with class/method/index. Key imports: InstructionQuery, BlwUtil, StringPredicate, InstructionPathNode. Add optional classFilter regex param. ~50-80 lines. See research-07c-bytecode-search.md Recommendation 1.","status":"closed","priority":1,"issue_type":"feature","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:40:25.440074781-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:55:35.098970284-05:00","closed_at":"2026-02-14T07:55:35.098970284-05:00","close_reason":"Implemented search-instruction-sequence tool using InstructionQuery - 16 new unit tests, 62 total passing","dependencies":[{"issue_id":"recaf-mcp-oht","depends_on_id":"recaf-mcp-m21","type":"blocks","created_at":"2026-02-14T07:40:34.677533469-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-p9y","title":"ClassResourceProvider doesn't handle slash-notation class URIs","description":"The recaf://class/{name} resource template only works with dot-notation class names (e.g., recaf://class/com.example.Main). Slash-notation URIs (recaf://class/com/example/Main) return 'Resource not found'. The provider should normalize slashes to dots before looking up the class.","status":"closed","priority":3,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T15:08:46.502110006-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:35:40.013374161-05:00","closed_at":"2026-02-13T15:35:40.013374161-05:00","close_reason":"Fixed description to recommend dot notation. The MCP SDK's DefaultMcpUriTemplateManager uses regex ([^/]+) for {name} variables, which inherently excludes slashes. This is an SDK-level limitation - the handler never receives slash-notation URIs. Updated description from 'slash notation' to 'dot notation' to match actual behavior."}
{"id":"recaf-mcp-pv1","title":"search-text-in-decompilation classFilter parameter may be broken","description":"The search-text-in-decompilation tool iterates classes in internal order (starting with library classes like netty), making it hard to find matches in application classes within the default limit. The classFilter parameter was passed but did not appear to narrow the search scope. Either classFilter is not implemented or it doesn't work as expected. This makes the tool unreliable for targeted searches in large workspaces.","status":"closed","priority":2,"issue_type":"bug","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T17:07:14.604135834-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:37:13.519128444-05:00","closed_at":"2026-02-14T07:37:13.519128444-05:00","close_reason":"Added classFilter and primaryOnly parameters to search-text-in-decompilation and search-instructions tools. classFilter narrows by package prefix before limiting. primaryOnly (default true) restricts to application classes only, skipping library/supporting resource classes. Added getFilteredClassStream helper to avoid duplication."}
{"id":"recaf-mcp-q23","title":"E2E: Bytecode modification via MCP - save RuneLite plugins to disk","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T15:28:04.310073463-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:28:10.51648276-05:00","closed_at":"2026-02-13T15:28:10.51648276-05:00","close_reason":"E2E success: decompiled HtmlUtils, modified DownloadJarFile to save to permanent dir, compiled and applied via compile-java, verified via decompile-diff"}
{"id":"recaf-mcp-r7v","title":"E2E test: verify TOON serialization format via MCP","description":"Perform end-to-end testing with ToonResponseSerializer enabled instead of the default JsonResponseSerializer. The TOON integration exists (ToonResponseSerializer.java, JToon dependency in build.gradle) but is not wired in — AbstractToolProvider always defaults to JsonResponseSerializer. Steps: (1) Identify or add a config/flag mechanism to switch the serializer to TOON (e.g. env var, system property, or MCP init param), (2) Build, deploy, and start Recaf with TOON enabled, (3) Exercise multiple tool calls across different providers and verify responses are valid TOON, (4) Confirm Claude Code / LLM clients can still parse TOON tool results correctly, (5) Compare token usage between JSON and TOON for representative responses.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T07:18:53.329620063-05:00","created_by":"tha23rd","updated_at":"2026-02-14T07:28:36.680172537-05:00","closed_at":"2026-02-14T07:28:36.680172537-05:00","close_reason":"TOON config wiring implemented and E2E tested. System property -Drecaf.mcp.format=toon switches all 13 tool providers to TOON serialization. E2E verified: 4 tools across 3 providers, all producing valid TOON. Token savings: 35.9% overall (24-67% per tool)."}
{"id":"recaf-mcp-txp","title":"vm-get-field tool implementation","description":"Add vm-get-field to SsvmExecutionProvider. Parameters: className, fieldName, fieldDescriptor (optional). Auto-triggers clinit if class not yet initialized. Reads static field via VMOperations typed getters (getInt, getLong, getDouble, getFloat, getChar, getShort, getByte, getBoolean, getReference). Same serialization as vm-invoke-method return values. Returns classInitialized boolean, classesInitialized list, captured stdout/stderr. Scope: static fields only in v1. Validation: unit test reading primitive fields, String fields, array fields (verify pagination at 1000 elements), verify clinit auto-triggers, verify field-not-found error.","notes":"Parent: recaf-mcp-62g. Depends on: vm-invoke-method task (shares SsvmExecutionProvider + serialization code). Key SSVM APIs: VMOperations.getInt/getLong/getReference, ops.readUtf8().","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-14T17:22:11.773733667-05:00","created_by":"tha23rd","updated_at":"2026-02-14T17:56:10.174047311-05:00","closed_at":"2026-02-14T17:56:10.174047311-05:00","close_reason":"vm-get-field implemented with field resolution, optional descriptor disambiguation, static field verification, type-based reading for all primitives + references. 16 tests added. QC approved.","dependencies":[{"issue_id":"recaf-mcp-txp","depends_on_id":"recaf-mcp-4gq","type":"blocks","created_at":"2026-02-14T17:22:36.996626825-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-u2j","title":"Test AssemblerToolProvider after implementation","description":"Test all 4 assembler tools after implementation: disassemble-method, assemble-method, disassemble-class, assemble-class. Verify each via MCP HTTP calls with the test workspace.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:53:12.002831944-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:28:10.87715425-05:00","closed_at":"2026-02-13T17:28:10.87715425-05:00","close_reason":"4/4 tests pass: disassemble-method (JASM output), disassemble-class (full class JASM), assemble-method (modified JASM applied), assemble-class (full class reassembled).","dependencies":[{"issue_id":"recaf-mcp-u2j","depends_on_id":"recaf-mcp-kmm","type":"blocks","created_at":"2026-02-13T16:53:20.825460325-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-ue8","title":"Implement TransformToolProvider (5 tools)","description":"Implement the 5 stubbed transform tools:\n- transform-list: List available bytecode transforms\n- transform-apply: Apply a transform to a class\n- transform-apply-batch: Apply transforms to multiple classes\n- transform-preview: Preview transform result without applying\n- transform-undo: Undo last transform\n\nNeeds Recaf API research: look for TransformManager, JvmClassTransformer, or similar services in Recaf's transform/refactor packages.","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T16:52:58.080856737-05:00","created_by":"tha23rd","updated_at":"2026-02-13T17:18:30.557768786-05:00","closed_at":"2026-02-13T17:18:30.557768786-05:00","close_reason":"Implemented 5 transform tools using TransformationManager: transform-list, transform-apply, transform-apply-batch, transform-preview, transform-undo with bytecode snapshot undo"}
{"id":"recaf-mcp-uep","title":"Implement compiler tools (compile-java, compile-check, phantom-generate)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T15:28:04.070260606-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:28:10.343615899-05:00","closed_at":"2026-02-13T15:28:10.343615899-05:00","close_reason":"Implemented compile-java, compile-check, phantom-generate tools using Recaf JavacCompiler and PhantomGenerator APIs"}
{"id":"recaf-mcp-vwk","title":"Task 19: AttachToolProvider (4 tools)","status":"closed","priority":2,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:10:24.963433133-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:13:49.977689883-05:00","closed_at":"2026-02-13T14:13:49.977689883-05:00","close_reason":"All Phase 4 tool providers implemented and compiling"}
{"id":"recaf-mcp-wc9","title":"Test: Mapping tools (rename-class, rename-method, rename-field)","description":"Rename a class, method, and field in the test JAR. Verify decompilation reflects the new names.","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:15.604484674-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:10:07.116266127-05:00","closed_at":"2026-02-13T15:10:07.116266127-05:00","close_reason":"All 5 mapping tests passed: rename-class, rename-class undo, rename-method, rename-field, all undone successfully","dependencies":[{"issue_id":"recaf-mcp-wc9","depends_on_id":"recaf-mcp-z7v","type":"blocks","created_at":"2026-02-13T14:22:28.820106504-05:00","created_by":"tha23rd"}]}
{"id":"recaf-mcp-wyt","title":"Task 9: DecompilerToolProvider (5 tools)","status":"closed","priority":1,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T13:56:04.618999262-05:00","created_by":"tha23rd","updated_at":"2026-02-13T14:09:44.135434445-05:00","closed_at":"2026-02-13T14:09:44.135434445-05:00","close_reason":"All Phase 3 tool providers implemented and compiling"}
{"id":"recaf-mcp-z7v","title":"Test: Open workspace with example JAR","description":"Use workspace-open tool to load a test JAR. Verify class count, file count, and workspace-get-info returns correct data.","status":"closed","priority":0,"issue_type":"task","owner":"zgbluhm@gmail.com","created_at":"2026-02-13T14:22:09.698543209-05:00","created_by":"tha23rd","updated_at":"2026-02-13T15:03:23.44293071-05:00","closed_at":"2026-02-13T15:03:23.44293071-05:00","close_reason":"workspace-open loads 16340 classes, decompile-class/search tools all working","dependencies":[{"issue_id":"recaf-mcp-z7v","depends_on_id":"recaf-mcp-nd5","type":"blocks","created_at":"2026-02-13T14:22:28.043812542-05:00","created_by":"tha23rd"}]}
