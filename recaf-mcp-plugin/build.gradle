plugins {
    id 'java'
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'com.gradleup.shadow' version '9.0.0-beta12'
}

group = 'dev.recafmcp'
version = '0.1.0'

ext {
    // Recaf snapshot version (commit hash from JitPack)
    recafVersion = 'd07958a5c7'
    recafSnapshots = true

    pluginMainClass = 'dev.recafmcp.RecafMcpPlugin'
    pluginName = 'Recaf MCP Server'
    pluginDesc = 'MCP server for autonomous Java reverse engineering via LLM agents'
    pluginId = group + '.' + project.name
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
    sourceCompatibility = JavaVersion.VERSION_22
    targetCompatibility = JavaVersion.VERSION_22
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url 'https://jitpack.io' }
}

configurations.configureEach {
    exclude group: 'org.checkerframework'
    exclude group: 'com.google.code.findbugs'
    exclude group: 'com.google.errorprone'
    exclude group: 'com.google.j2objc'
    exclude group: 'org.jetbrains', module: 'annotations'
    exclude group: 'com.android.tools'
    exclude group: 'com.ibm.icu'
}

configurations {
    // Dependencies provided by Recaf at runtime (don't shade these)
    recafProvided
    compileOnly.extendsFrom(recafProvided)
    testImplementation.extendsFrom(recafProvided)

    // Dependencies we need to shade into the plugin JAR
    shade
    implementation.extendsFrom(shade)

}

dependencies {
    // Recaf (provided at runtime, not shaded)
    if (recafSnapshots) {
        recafProvided "com.github.Col-E.Recaf:recaf-core:${recafVersion}"
        recafProvided "com.github.Col-E.Recaf:recaf-ui:${recafVersion}"
    } else {
        recafProvided "software.coley:recaf-core:${recafVersion}"
        recafProvided "software.coley:recaf-ui:${recafVersion}"
    }

    // MCP SDK (shaded into plugin JAR)
    shade platform('io.modelcontextprotocol.sdk:mcp-bom:0.17.2')
    shade 'io.modelcontextprotocol.sdk:mcp'

    // Embedded HTTP server - Jetty 12.1 with ee11 (Jakarta Servlet 6.1)
    shade 'org.eclipse.jetty:jetty-server:12.1.6'
    shade 'org.eclipse.jetty.ee11:jetty-ee11-servlet:12.1.6'

    // TOON serialization (for token-efficient responses)
    shade 'dev.toonformat:jtoon:1.0.8'

    // Test
    testImplementation platform('org.junit:junit-bom:5.11.2')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.mockito:mockito-core:5.14.2'
}

test {
    useJUnitPlatform()
}

javafx {
    version = '22.0.1'
    modules = ['javafx.base', 'javafx.graphics', 'javafx.controls', 'javafx.media']
}

// Generate BuildConfig.java with plugin metadata constants
def generatedSrcDir = layout.buildDirectory.dir('generated/sources/buildconfig/java/main')
sourceSets.main.java.srcDir(generatedSrcDir)

tasks.register('generateBuildConfig') {
    outputs.dir(generatedSrcDir)
    doFirst {
        def dir = generatedSrcDir.get().asFile.toPath().resolve('dev/recafmcp')
        dir.toFile().mkdirs()
        dir.resolve('BuildConfig.java').toFile().text = """\
package dev.recafmcp;

/** Auto-generated plugin metadata constants. */
public final class BuildConfig {
    public static final String PLUGIN_ID = "${project.ext.pluginId}";
    public static final String PLUGIN_NAME = "${project.ext.pluginName}";
    public static final String PLUGIN_DESC = "${project.ext.pluginDesc}";
    public static final String PLUGIN_VERSION = "${project.version}";
    private BuildConfig() {}
}
"""
    }
}

tasks.named('compileJava').configure {
    dependsOn 'generateBuildConfig'
}

// ServiceLoader entry for Recaf plugin discovery
tasks.register('setupServiceEntry') {
    outputs.dir(temporaryDir)
    doFirst {
        new File(temporaryDir, "META-INF/services").mkdirs()
        new File(temporaryDir, "META-INF/services/software.coley.recaf.plugin.Plugin").text = project.ext.pluginMainClass
    }
}

// Shadow JAR: bundle MCP SDK, Jetty, and TOON into the plugin JAR
// Excludes Recaf's own dependencies (they're on the classpath at runtime)
shadowJar {
    configurations = [project.configurations.shade]
    archiveClassifier.set('')

    // Relocate to avoid classpath conflicts
    relocate 'org.eclipse.jetty', 'dev.recafmcp.shadow.jetty'
    relocate 'io.modelcontextprotocol', 'dev.recafmcp.shadow.mcp'
    relocate 'dev.toonformat', 'dev.recafmcp.shadow.toon'

    from(tasks.named('setupServiceEntry'))

    mergeServiceFiles()
}

// Make the default jar task produce the shadow jar
jar.enabled = false
tasks.named('build').configure {
    dependsOn shadowJar
}

// Run Recaf with plugin loaded.
// Expects a pre-built recaf.jar in run/ directory.
// Copies the shadow JAR into Recaf's data directory (~/.config/Recaf/plugins/)
// so Recaf discovers it at startup.
// JavaFX JARs from the Gradle cache are added to --module-path since the
// Homebrew/standard JDK does not bundle JavaFX.
tasks.register('runRecaf', JavaExec) {
    dependsOn 'shadowJar'
    def recafJar = file('run/recaf.jar')
    classpath = files(recafJar)
    mainClass = 'software.coley.recaf.Main'
    workingDir = file('run')
    doFirst {
        if (!recafJar.exists()) {
            throw new GradleException("Place recaf.jar in run/ directory. " +
                    "Download from https://github.com/Col-E/Recaf or copy from your Recaf installation.")
        }
        // Determine Recaf data directory and copy plugin there
        def osName = System.getProperty('os.name', '').toLowerCase()
        def recafDir
        if (osName.contains('win')) {
            recafDir = new File(System.getenv('APPDATA'), 'Recaf')
        } else if (osName.contains('mac')) {
            recafDir = new File(System.getProperty('user.home'), 'Library/Application Support/Recaf')
        } else {
            recafDir = new File(System.getProperty('user.home'), '.config/Recaf')
        }
        def pluginsDir = new File(recafDir, 'plugins')
        pluginsDir.mkdirs()
        project.copy {
            from tasks.named('shadowJar').get().archiveFile
            into pluginsDir
        }
        logger.lifecycle("Installed plugin to {}", pluginsDir)
        // Resolve JavaFX platform JARs from the runtimeClasspath (populated by javafx plugin)
        def jfxJars = configurations.runtimeClasspath.files.findAll { it.name.contains('javafx') }
        def modulePath = jfxJars.collect { it.absolutePath }.join(File.pathSeparator)
        jvmArgs += [
                '--module-path', modulePath,
                '--add-modules', 'javafx.base,javafx.graphics,javafx.controls,javafx.media',
                '--add-opens', 'javafx.graphics/com.sun.javafx.application=ALL-UNNAMED'
        ]
    }
}
